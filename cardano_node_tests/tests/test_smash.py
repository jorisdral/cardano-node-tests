"""Tests for operations with stake pools and SMASH.

* pool registration
* pool deregistration
* pool metadata
* pool reregistration
"""
# pylint: disable=abstract-class-instantiated
import json
import logging
import time
from pathlib import Path
from typing import List
from typing import Optional
from typing import Tuple

import allure
import pytest
from _pytest.fixtures import FixtureRequest
from _pytest.tmpdir import TempdirFactory
from cardano_clusterlib import clusterlib

import cardano_node_tests.utils.smash_utils as smash
from cardano_node_tests.tests import common
from cardano_node_tests.utils import cluster_management
from cardano_node_tests.utils import cluster_nodes
from cardano_node_tests.utils import clusterlib_utils
from cardano_node_tests.utils import dbsync_utils
from cardano_node_tests.utils import helpers
from cardano_node_tests.utils import locking
from cardano_node_tests.utils import temptools

LOGGER = logging.getLogger(__name__)
DEREG_BUFFER_SEC = 30


@pytest.fixture(scope="module")
def create_temp_dir(tmp_path_factory: TempdirFactory):
    """Create a temporary dir."""
    p = Path(tmp_path_factory.getbasetemp()).joinpath(helpers.get_id_for_mktemp(__file__)).resolve()
    p.mkdir(exist_ok=True, parents=True)
    return p


@pytest.fixture
def temp_dir(create_temp_dir: Path):
    """Change to a temporary dir."""
    with helpers.change_cwd(create_temp_dir):
        yield create_temp_dir


# use the "temp_dir" fixture for all tests automatically
pytestmark = pytest.mark.usefixtures("temp_dir")


@pytest.fixture(scope="module")
def pool_cost_start_cluster(tmp_path_factory: TempdirFactory) -> Path:
    """Update *minPoolCost* to 500."""
    shared_tmp = temptools.get_pytest_shared_tmp(tmp_path_factory)

    # need to lock because this same fixture can run on several workers in parallel
    with locking.FileLockIfXdist(f"{shared_tmp}/startup_files_pool_500.lock"):
        destdir = shared_tmp / "startup_files_pool_500"
        destdir.mkdir(exist_ok=True)

        # return existing script if it is already generated by other worker
        destdir_ls = list(destdir.glob("start-cluster*"))
        if destdir_ls:
            return destdir_ls[0]

        startup_files = cluster_nodes.get_cluster_type().cluster_scripts.copy_scripts_files(
            destdir=destdir
        )
        with open(startup_files.genesis_spec, encoding="utf-8") as fp_in:
            genesis_spec = json.load(fp_in)

        genesis_spec["protocolParams"]["minPoolCost"] = 500

        with open(startup_files.genesis_spec, "w", encoding="utf-8") as fp_out:
            json.dump(genesis_spec, fp_out)

        return startup_files.start_script


@pytest.fixture
def cluster_mincost(
    cluster_manager: cluster_management.ClusterManager, pool_cost_start_cluster: Path
) -> clusterlib.ClusterLib:
    return cluster_manager.get(
        mark="minPoolCost", cleanup=True, start_cmd=str(pool_cost_start_cluster)
    )


def _check_pool(
    cluster_obj: clusterlib.ClusterLib,
    stake_pool_id: str,
    pool_data: clusterlib.PoolData,
):
    """Check and return ledger state of the pool, and optionaly also db-sync records."""
    pool_params: dict = cluster_obj.get_pool_params(stake_pool_id).pool_params

    assert pool_params, (
        "The newly created stake pool id is not shown inside the available stake pools;\n"
        f"Pool ID: {stake_pool_id} vs Existing IDs: "
        f"{list(cluster_obj.get_registered_stake_pools_ledger_state())}"
    )
    assert not clusterlib_utils.check_pool_data(
        pool_params=pool_params, pool_creation_data=pool_data
    )

    # check pool data in db-sync if available
    dbsync_utils.check_pool_data(ledger_pool_data=pool_params, pool_id=stake_pool_id)


def _check_staking(
    pool_owners: List[clusterlib.PoolUser],
    cluster_obj: clusterlib.ClusterLib,
    stake_pool_id: str,
):
    """Check that staking was correctly setup."""
    pool_params: dict = cluster_obj.get_pool_params(stake_pool_id).pool_params

    LOGGER.info("Waiting up to 3 full epochs for stake pool to be registered.")
    for i in range(4):
        if i > 0:
            cluster_obj.wait_for_new_epoch(padding_seconds=10)
        if stake_pool_id in cluster_obj.get_stake_distribution():
            break
    else:
        raise AssertionError(f"Stake pool `{stake_pool_id}` not registered even after 3 epochs.")

    for owner in pool_owners:
        stake_addr_info = cluster_obj.get_stake_addr_info(owner.stake.address)

        # check that the stake address was delegated
        assert stake_addr_info.delegation, f"Stake address was not delegated yet: {stake_addr_info}"
        assert stake_pool_id == stake_addr_info.delegation, "Stake address delegated to wrong pool"

        assert (
            # strip 'e0' from the beginning of the address hash
            helpers.decode_bech32(stake_addr_info.address)[2:]
            in pool_params["owners"]
        ), "'owner' value is different than expected"


def _register_stake_pool_w_build(
    cluster_obj: clusterlib.ClusterLib,
    pool_data: clusterlib.PoolData,
    pool_owners: List[clusterlib.PoolUser],
    vrf_vkey_file: clusterlib.FileType,
    cold_key_pair: clusterlib.ColdKeyPair,
    tx_name: str,
    reward_account_vkey_file: Optional[clusterlib.FileType] = None,
    deposit: Optional[int] = None,
    destination_dir: clusterlib.FileType = ".",
) -> Tuple[Path, clusterlib.TxRawOutput]:
    """Register a stake pool using a `transaction build` command.

    Args:
        cluster_obj: An instance of `clusterlib.ClusterLib`.
        pool_data: A `PoolData` tuple cointaining info about the stake pool.
        pool_owners: A list of `PoolUser` structures containing pool user addresses and keys.
        vrf_vkey_file: A path to node VRF vkey file.
        cold_key_pair: A `ColdKeyPair` tuple containing the key pair and the counter.
        tx_name: A name of the transaction.
        reward_account_vkey_file: A path to reward account vkey file (optional).
        deposit: A deposit amount needed by the transaction (optional).
        destination_dir: A path to directory for storing artifacts (optional).

    Returns:
        Tuple[Path, TxRawOutput]: A tuple with pool registration cert file and transaction
            output details.
    """
    tx_name = f"{tx_name}_reg_pool"
    pool_reg_cert_file = cluster_obj.gen_pool_registration_cert(
        pool_data=pool_data,
        vrf_vkey_file=vrf_vkey_file,
        cold_vkey_file=cold_key_pair.vkey_file,
        owner_stake_vkey_files=[p.stake.vkey_file for p in pool_owners],
        reward_account_vkey_file=reward_account_vkey_file,
        destination_dir=destination_dir,
    )

    # submit the pool registration certificate through a tx
    tx_files = clusterlib.TxFiles(
        certificate_files=[pool_reg_cert_file],
        signing_key_files=[
            *[p.payment.skey_file for p in pool_owners],
            *[p.stake.skey_file for p in pool_owners],
            cold_key_pair.skey_file,
        ],
    )

    tx_raw_output = cluster_obj.build_tx(
        src_address=pool_owners[0].payment.address,
        tx_name=tx_name,
        tx_files=tx_files,
        deposit=deposit,
        fee_buffer=2000_000,
        witness_override=len(pool_owners) * 3,
        destination_dir=destination_dir,
    )
    tx_signed = cluster_obj.sign_tx(
        tx_body_file=tx_raw_output.out_file,
        signing_key_files=tx_files.signing_key_files,
        tx_name=tx_name,
    )
    cluster_obj.submit_tx(tx_file=tx_signed, txins=tx_raw_output.txins)

    dbsync_utils.check_tx(cluster_obj=cluster_obj, tx_raw_output=tx_raw_output)

    return pool_reg_cert_file, tx_raw_output


def _create_stake_pool_w_build(
    cluster_obj: clusterlib.ClusterLib,
    pool_data: clusterlib.PoolData,
    pool_owners: List[clusterlib.PoolUser],
    tx_name: str,
    destination_dir: clusterlib.FileType = ".",
) -> clusterlib.PoolCreationOutput:
    """Create and register a stake pool using a `transaction build` command.

    Args:
        cluster_obj: An instance of `clusterlib.ClusterLib`.
        pool_data: A `PoolData` tuple cointaining info about the stake pool.
        pool_owners: A list of `PoolUser` structures containing pool user addresses and keys.
        tx_name: A name of the transaction.
        destination_dir: A path to directory for storing artifacts (optional).

    Returns:
        PoolCreationOutput: A tuple containing pool creation output.
    """
    # create the KES key pair
    node_kes = cluster_obj.gen_kes_key_pair(
        node_name=pool_data.pool_name,
        destination_dir=destination_dir,
    )
    LOGGER.debug(f"KES keys created - {node_kes.vkey_file}; {node_kes.skey_file}")

    # create the VRF key pair
    node_vrf = cluster_obj.gen_vrf_key_pair(
        node_name=pool_data.pool_name,
        destination_dir=destination_dir,
    )
    LOGGER.debug(f"VRF keys created - {node_vrf.vkey_file}; {node_vrf.skey_file}")

    # create the cold key pair and node operational certificate counter
    node_cold = cluster_obj.gen_cold_key_pair_and_counter(
        node_name=pool_data.pool_name,
        destination_dir=destination_dir,
    )
    LOGGER.debug(
        "Cold keys created and counter created - "
        f"{node_cold.vkey_file}; {node_cold.skey_file}; {node_cold.counter_file}"
    )

    pool_reg_cert_file, tx_raw_output = _register_stake_pool_w_build(
        cluster_obj=cluster_obj,
        pool_data=pool_data,
        pool_owners=pool_owners,
        vrf_vkey_file=node_vrf.vkey_file,
        cold_key_pair=node_cold,
        tx_name=tx_name,
        destination_dir=destination_dir,
    )

    dbsync_utils.check_tx(cluster_obj=cluster_obj, tx_raw_output=tx_raw_output)

    return clusterlib.PoolCreationOutput(
        stake_pool_id=cluster_obj.get_stake_pool_id(node_cold.vkey_file),
        vrf_key_pair=node_vrf,
        cold_key_pair=node_cold,
        pool_reg_cert_file=pool_reg_cert_file,
        pool_data=pool_data,
        pool_owners=pool_owners,
        tx_raw_output=tx_raw_output,
        kes_key_pair=node_kes,
    )


def _deregister_stake_pool_w_build(
    cluster_obj: clusterlib.ClusterLib,
    pool_owners: List[clusterlib.PoolUser],
    cold_key_pair: clusterlib.ColdKeyPair,
    epoch: int,
    pool_name: str,
    tx_name: str,
    destination_dir: clusterlib.FileType = ".",
) -> Tuple[Path, clusterlib.TxRawOutput]:
    """Deregister a stake pool.

    Args:
        cluster_obj: An instance of `clusterlib.ClusterLib`.
        pool_owners: A list of `PoolUser` structures containing pool user addresses and keys.
        cold_key_pair: A `ColdKeyPair` tuple containing the key pair and the counter.
        epoch: An epoch where the update proposal will take effect (optional).
        pool_name: A name of the stake pool.
        tx_name: A name of the transaction.
        destination_dir: A path to directory for storing artifacts (optional).

    Returns:
        Tuple[Path, TxRawOutput]: A tuple with pool registration cert file and transaction
            output details.
    """
    tx_name = f"{tx_name}_dereg_pool"
    LOGGER.debug(
        f"Deregistering stake pool starting with epoch: {epoch}; "
        f"Current epoch is: {cluster_obj.get_epoch()}"
    )
    pool_dereg_cert_file = cluster_obj.gen_pool_deregistration_cert(
        pool_name=pool_name,
        cold_vkey_file=cold_key_pair.vkey_file,
        epoch=epoch,
        destination_dir=destination_dir,
    )

    # submit the pool deregistration certificate through a tx
    tx_files = clusterlib.TxFiles(
        certificate_files=[pool_dereg_cert_file],
        signing_key_files=[
            *[p.payment.skey_file for p in pool_owners],
            *[p.stake.skey_file for p in pool_owners],
            cold_key_pair.skey_file,
        ],
    )

    tx_raw_output = cluster_obj.build_tx(
        src_address=pool_owners[0].payment.address,
        tx_name=tx_name,
        tx_files=tx_files,
        fee_buffer=2000_000,
        witness_override=len(pool_owners) * 3,
        destination_dir=destination_dir,
    )
    tx_signed = cluster_obj.sign_tx(
        tx_body_file=tx_raw_output.out_file,
        signing_key_files=tx_files.signing_key_files,
        tx_name=tx_name,
    )
    cluster_obj.submit_tx(tx_file=tx_signed, txins=tx_raw_output.txins)

    dbsync_utils.check_tx(cluster_obj=cluster_obj, tx_raw_output=tx_raw_output)

    return pool_dereg_cert_file, tx_raw_output


def _create_register_pool(
    cluster_obj: clusterlib.ClusterLib,
    temp_template: str,
    temp_dir: Path,
    pool_owners: List[clusterlib.PoolUser],
    pool_data: clusterlib.PoolData,
    request: Optional[FixtureRequest] = None,
    use_build_cmd: bool = False,
) -> clusterlib.PoolCreationOutput:
    """Create and register a stake pool.

    Common functionality for tests.
    """
    src_address = pool_owners[0].payment.address
    src_init_balance = cluster_obj.get_address_balance(src_address)

    # create and register pool
    if use_build_cmd:
        pool_creation_out = _create_stake_pool_w_build(
            cluster_obj=cluster_obj,
            pool_data=pool_data,
            pool_owners=pool_owners,
            tx_name=temp_template,
        )
    else:
        pool_creation_out = cluster_obj.create_stake_pool(
            pool_data=pool_data, pool_owners=pool_owners, tx_name=temp_template
        )
        dbsync_utils.check_tx(
            cluster_obj=cluster_obj, tx_raw_output=pool_creation_out.tx_raw_output
        )

    # deregister stake pool
    def _deregister():
        depoch = 1 if cluster_obj.time_to_epoch_end() >= DEREG_BUFFER_SEC else 2
        with helpers.change_cwd(temp_dir):
            cluster_obj.deregister_stake_pool(
                pool_owners=pool_owners,
                cold_key_pair=pool_creation_out.cold_key_pair,
                epoch=cluster_obj.get_epoch() + depoch,
                pool_name=pool_data.pool_name,
                tx_name=temp_template,
            )

    if request is not None:
        request.addfinalizer(_deregister)

    # check that the balance for source address was correctly updated
    assert (
        cluster_obj.get_address_balance(src_address)
        == src_init_balance - cluster_obj.get_pool_deposit() - pool_creation_out.tx_raw_output.fee
    ), f"Incorrect balance for source address `{src_address}`"

    # check that pool was correctly setup
    _check_pool(
        cluster_obj=cluster_obj,
        stake_pool_id=pool_creation_out.stake_pool_id,
        pool_data=pool_data,
    )

    return pool_creation_out


def _create_register_pool_delegate_stake_tx(
    cluster_obj: clusterlib.ClusterLib,
    pool_owners: List[clusterlib.PoolUser],
    temp_template: str,
    temp_dir: Path,
    pool_data: clusterlib.PoolData,
    request: Optional[FixtureRequest] = None,
    use_build_cmd: bool = False,
) -> clusterlib.PoolCreationOutput:
    """Create and register a stake pool, delegate stake address - all in single TX.

    Common functionality for tests.
    """
    # create node VRF key pair
    node_vrf = cluster_obj.gen_vrf_key_pair(node_name=pool_data.pool_name)
    # create node cold key pair and counter
    node_cold = cluster_obj.gen_cold_key_pair_and_counter(node_name=pool_data.pool_name)

    # create stake address registration certs
    stake_addr_reg_cert_files = [
        cluster_obj.gen_stake_addr_registration_cert(
            addr_name=f"{temp_template}_addr{i}", stake_vkey_file=p.stake.vkey_file
        )
        for i, p in enumerate(pool_owners)
    ]

    # create stake address delegation cert
    stake_addr_deleg_cert_files = [
        cluster_obj.gen_stake_addr_delegation_cert(
            addr_name=f"{temp_template}_addr{i}",
            stake_vkey_file=p.stake.vkey_file,
            cold_vkey_file=node_cold.vkey_file,
        )
        for i, p in enumerate(pool_owners)
    ]

    # create stake pool registration cert
    pool_reg_cert_file = cluster_obj.gen_pool_registration_cert(
        pool_data=pool_data,
        vrf_vkey_file=node_vrf.vkey_file,
        cold_vkey_file=node_cold.vkey_file,
        owner_stake_vkey_files=[p.stake.vkey_file for p in pool_owners],
    )

    src_address = pool_owners[0].payment.address
    src_init_balance = cluster_obj.get_address_balance(src_address)

    # register and delegate stake address, create and register pool
    tx_files = clusterlib.TxFiles(
        certificate_files=[
            pool_reg_cert_file,
            *stake_addr_reg_cert_files,
            *stake_addr_deleg_cert_files,
        ],
        signing_key_files=[
            *[p.payment.skey_file for p in pool_owners],
            *[p.stake.skey_file for p in pool_owners],
            node_cold.skey_file,
        ],
    )

    if use_build_cmd:
        tx_raw_output = cluster_obj.build_tx(
            src_address=src_address,
            tx_name=temp_template,
            tx_files=tx_files,
            fee_buffer=2000_000,
            witness_override=len(pool_owners) * 3,
        )
        tx_signed = cluster_obj.sign_tx(
            tx_body_file=tx_raw_output.out_file,
            signing_key_files=tx_files.signing_key_files,
            tx_name=temp_template,
        )
        cluster_obj.submit_tx(tx_file=tx_signed, txins=tx_raw_output.txins)
    else:
        tx_raw_output = cluster_obj.send_tx(
            src_address=src_address, tx_name=temp_template, tx_files=tx_files
        )

    # deregister stake pool
    def _deregister():
        depoch = 1 if cluster_obj.time_to_epoch_end() >= DEREG_BUFFER_SEC else 2
        with helpers.change_cwd(temp_dir):
            cluster_obj.deregister_stake_pool(
                pool_owners=pool_owners,
                cold_key_pair=node_cold,
                epoch=cluster_obj.get_epoch() + depoch,
                pool_name=pool_data.pool_name,
                tx_name=temp_template,
            )

    if request is not None:
        request.addfinalizer(_deregister)

    # check that the balance for source address was correctly updated
    assert (
        cluster_obj.get_address_balance(src_address)
        == src_init_balance
        - len(pool_owners) * cluster_obj.get_address_deposit()
        - cluster_obj.get_pool_deposit()
        - tx_raw_output.fee
    ), f"Incorrect balance for source address `{src_address}`"

    # check that pool and staking were correctly setup
    stake_pool_id = cluster_obj.get_stake_pool_id(node_cold.vkey_file)
    _check_pool(cluster_obj=cluster_obj, stake_pool_id=stake_pool_id, pool_data=pool_data)
    _check_staking(
        pool_owners,
        cluster_obj=cluster_obj,
        stake_pool_id=stake_pool_id,
    )

    dbsync_utils.check_tx(cluster_obj=cluster_obj, tx_raw_output=tx_raw_output)

    return clusterlib.PoolCreationOutput(
        stake_pool_id=stake_pool_id,
        vrf_key_pair=node_vrf,
        cold_key_pair=node_cold,
        pool_reg_cert_file=pool_reg_cert_file,
        pool_data=pool_data,
        pool_owners=pool_owners,
        tx_raw_output=tx_raw_output,
    )


def _create_register_pool_tx_delegate_stake_tx(
    cluster_obj: clusterlib.ClusterLib,
    pool_owners: List[clusterlib.PoolUser],
    temp_template: str,
    temp_dir: Path,
    pool_data: clusterlib.PoolData,
    request: Optional[FixtureRequest] = None,
    use_build_cmd: bool = False,
) -> clusterlib.PoolCreationOutput:
    """Create and register a stake pool - first TX; delegate stake address - second TX.

    Common functionality for tests.
    """
    # create and register pool
    pool_creation_out = _create_register_pool(
        cluster_obj=cluster_obj,
        temp_template=temp_template,
        temp_dir=temp_dir,
        pool_owners=pool_owners,
        pool_data=pool_data,
        request=request,
        use_build_cmd=use_build_cmd,
    )

    # create stake address registration certs
    stake_addr_reg_cert_files = [
        cluster_obj.gen_stake_addr_registration_cert(
            addr_name=f"{temp_template}_addr{i}", stake_vkey_file=p.stake.vkey_file
        )
        for i, p in enumerate(pool_owners)
    ]

    # create stake address delegation cert
    stake_addr_deleg_cert_files = [
        cluster_obj.gen_stake_addr_delegation_cert(
            addr_name=f"{temp_template}_addr{i}",
            stake_vkey_file=p.stake.vkey_file,
            cold_vkey_file=pool_creation_out.cold_key_pair.vkey_file,
        )
        for i, p in enumerate(pool_owners)
    ]

    src_address = pool_owners[0].payment.address
    src_init_balance = cluster_obj.get_address_balance(src_address)

    # register and delegate stake address
    tx_files = clusterlib.TxFiles(
        certificate_files=[*stake_addr_reg_cert_files, *stake_addr_deleg_cert_files],
        signing_key_files=[
            *[p.payment.skey_file for p in pool_owners],
            *[p.stake.skey_file for p in pool_owners],
            pool_creation_out.cold_key_pair.skey_file,
        ],
    )

    if use_build_cmd:
        tx_raw_output = cluster_obj.build_tx(
            src_address=src_address,
            tx_name=temp_template,
            tx_files=tx_files,
            fee_buffer=2000_000,
            witness_override=len(pool_owners) * 3,
        )
        tx_signed = cluster_obj.sign_tx(
            tx_body_file=tx_raw_output.out_file,
            signing_key_files=tx_files.signing_key_files,
            tx_name=temp_template,
        )
        cluster_obj.submit_tx(tx_file=tx_signed, txins=tx_raw_output.txins)
    else:
        tx_raw_output = cluster_obj.send_tx(
            src_address=src_address, tx_name=temp_template, tx_files=tx_files
        )

    # check that the balance for source address was correctly updated
    assert (
        cluster_obj.get_address_balance(src_address)
        == src_init_balance
        - len(pool_owners) * cluster_obj.get_address_deposit()
        - tx_raw_output.fee
    ), f"Incorrect balance for source address `{src_address}`"

    # check that staking was correctly setup
    _check_staking(
        pool_owners,
        cluster_obj=cluster_obj,
        stake_pool_id=pool_creation_out.stake_pool_id,
    )

    dbsync_utils.check_tx(cluster_obj=cluster_obj, tx_raw_output=tx_raw_output)

    return pool_creation_out


@pytest.mark.order(2)
@pytest.mark.testnets
@pytest.mark.long
@pytest.mark.dbsync
@pytest.mark.needs_smash
class TestStakePoolWithSmash:
    """General tests for SMASH and stake pools."""

    @allure.link(helpers.get_vcs_link())
    def test_reregister_stake_pool_with_smash(
        self,
        cluster_manager: cluster_management.ClusterManager,
        cluster: clusterlib.ClusterLib,
        temp_dir: Path,
        request: FixtureRequest,
    ):
        """Reregister stake pool.

        * register stake pool and check smash for pool metadata
        * deregister stake pool
        * check smash for pool metadata before deregistartion epoch
        * check smash for pool metadata when deregistartion epoch is active
        * check that the stake addresses are no longer delegated
        * reregister the pool by resubmitting the pool registration certificate
        * check smash for pool metadata
        * delegate stake address to pool again (the address is already registered)
        * check that pool was correctly setup
        * check that the stake addresses were delegated
        """
        rand_str = clusterlib.get_rand_str(4)
        temp_template = f"{common.get_test_id(cluster)}_{rand_str}"

        pool_name = "SMASH_Test_Pool"
        pool_metadata = {
            "name": pool_name,
            "ticker": "QAS",
            "homepage": "https://github.com/input-output-hk/cardano-node-tests",
            "description": "QA Metadata for SMASH Test Pool",
        }

        pool_metadata_file = helpers.write_json(
            temp_dir / f"{pool_name}_registration_metadata.json", pool_metadata
        )

        pool_data = clusterlib.PoolData(
            pool_name=pool_name,
            pool_pledge=222,
            pool_cost=cluster.get_protocol_params().get("minPoolCost", 500),
            pool_margin=0.512,
            pool_metadata_url="https://bit.ly/3IVZa2a",
            pool_metadata_hash=cluster.gen_pool_metadata_hash(pool_metadata_file),
        )

        # create pool owners
        pool_owners = clusterlib_utils.create_pool_users(
            cluster_obj=cluster, name_template=temp_template
        )

        # fund source address
        clusterlib_utils.fund_from_faucet(
            pool_owners[0].payment,
            cluster_obj=cluster,
            faucet_data=cluster_manager.cache.addrs_data["user1"],
            amount=1_500_000_000,
        )

        # register pool and delegate stake address
        pool_creation_out = _create_register_pool_delegate_stake_tx(
            cluster_obj=cluster,
            pool_owners=pool_owners,
            temp_template=temp_template,
            temp_dir=temp_dir,
            pool_data=pool_data,
        )

        # check smash for pool metadata s1 - should be available
        time.sleep(60)
        pool_hash = cluster.get_pool_params(pool_creation_out.stake_pool_id)[0]["publicKey"]
        metadata_hash = pool_data[5]
        response = smash.fetch_metadata(pool_hash, metadata_hash)
        assert json.dumps(response.json()) == json.dumps(pool_metadata)

        # deregister stake pool
        clusterlib_utils.wait_for_epoch_interval(
            cluster_obj=cluster, start=5, stop=-DEREG_BUFFER_SEC, force_epoch=False
        )
        depoch = cluster.get_epoch() + 2
        cluster.deregister_stake_pool(
            pool_owners=pool_owners,
            cold_key_pair=pool_creation_out.cold_key_pair,
            epoch=depoch,
            pool_name=pool_data.pool_name,
            tx_name=temp_template,
        )
        assert cluster.get_pool_params(pool_creation_out.stake_pool_id).retiring == depoch

        # check smash for pool metadata s2 - should be still available; we are in (depoch-1)
        cluster.wait_for_new_epoch()
        response = smash.fetch_metadata(pool_creation_out.stake_pool_id, metadata_hash)
        assert json.dumps(response.json()) == json.dumps(pool_metadata)

        # check that the pool was deregistered
        cluster.wait_for_new_epoch()
        assert not (
            cluster.get_pool_params(pool_creation_out.stake_pool_id).pool_params
        ), f"The pool {pool_creation_out.stake_pool_id} was not deregistered"

        dbsync_utils.check_pool_deregistration(
            pool_id=pool_creation_out.stake_pool_id, retiring_epoch=depoch
        )

        # check that the stake addresses are no longer delegated
        for owner_rec in pool_owners:
            stake_addr_info = cluster.get_stake_addr_info(owner_rec.stake.address)
            assert (
                not stake_addr_info.delegation
            ), f"Stake address is still delegated: {stake_addr_info}"

        src_address = pool_owners[0].payment.address
        src_init_balance = cluster.get_address_balance(src_address)

        # check smash for pool metadata s3 - check that pool is retired - we are in depoch
        response = smash.fetch_metadata(pool_hash, metadata_hash)
        assert response.text == f"Pool {pool_hash} is retired"

        # reregister the pool by resubmitting the pool registration certificate,
        # delegate stake address to pool again (the address is already registered)
        tx_files = clusterlib.TxFiles(
            certificate_files=[
                pool_creation_out.pool_reg_cert_file,
                *list(temp_dir.glob(f"{temp_template}*_stake_deleg.cert")),
            ],
            signing_key_files=pool_creation_out.tx_raw_output.tx_files.signing_key_files,
        )
        tx_raw_output = cluster.send_tx(
            src_address=src_address, tx_name=temp_template, tx_files=tx_files
        )

        # check smash for pool metadata s4 - it should be available again after reregistration
        cluster.wait_for_new_epoch()
        response = smash.fetch_metadata(pool_creation_out.stake_pool_id, metadata_hash)
        assert json.dumps(response.json()) == json.dumps(pool_metadata)

        # deregister stake pool
        def _deregister():
            depoch = 1 if cluster.time_to_epoch_end() >= DEREG_BUFFER_SEC else 2
            with helpers.change_cwd(temp_dir):
                cluster.deregister_stake_pool(
                    pool_owners=pool_owners,
                    cold_key_pair=pool_creation_out.cold_key_pair,
                    epoch=cluster.get_epoch() + depoch,
                    pool_name=pool_data.pool_name,
                    tx_name=temp_template,
                )

        request.addfinalizer(_deregister)

        # check that the balance for source address was correctly updated
        assert (
            cluster.get_address_balance(src_address)
            == src_init_balance - tx_raw_output.fee - cluster.get_pool_deposit()
        ), (
            f"Incorrect balance for source address `{src_address}` "
            f"({src_init_balance}, {tx_raw_output.fee}, {cluster.get_pool_deposit()})"
        )

        LOGGER.info("Waiting up to 5 full epochs for stake pool to be reregistered.")
        for __ in range(5):
            cluster.wait_for_new_epoch(padding_seconds=10)
            if pool_creation_out.stake_pool_id in cluster.get_stake_distribution():
                break
        else:
            raise AssertionError(
                f"Stake pool `{pool_creation_out.stake_pool_id}` not registered "
                "even after 5 epochs."
            )
        # check that pool was correctly setup
        _check_pool(
            cluster_obj=cluster, stake_pool_id=pool_creation_out.stake_pool_id, pool_data=pool_data
        )

        # check that the stake addresses were delegated
        _check_staking(
            pool_owners=pool_owners,
            cluster_obj=cluster,
            stake_pool_id=pool_creation_out.stake_pool_id,
        )

        dbsync_utils.check_tx(cluster_obj=cluster, tx_raw_output=tx_raw_output)
